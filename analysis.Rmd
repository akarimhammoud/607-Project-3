---
title: "Project 3"
author: "Diego Correa"
date: "9/8/2020"
output:
  pdf_document: default
  html_document: default
---

## Overview



## Loading data

```{r cars}
library(tidyverse, quietly = TRUE)

#Presidential National Toplines
url1 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_national_toplines_2020.csv'
#Presidential State Toplines
url2 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_state_toplines_2020.csv'
#Presidential EV Probabilities
url3 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_ev_probabilities_2020.csv'
#Presidential Scenario Analysis
url4 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_scenario_analysis_2020.csv'
#Economic Index
url5 <- 'https://projects.fivethirtyeight.com/2020-general-data/economic_index.csv'

#Saving data into variables
dfPNT <- read.csv(file = url1)
dfPST <- read.csv(file = url2)
dfPEP <- read.csv(file = url3)
dfPSA <- read.csv(file = url4)
dfEI <- read.csv(file = url5)
```

## Observing & Cleaning 


```{r}
str(dfEI)
# str(dfPNT)
# str(dfPST)
# str(dfPEP)
# str(dfPSA)
```

When we look at the dataframes, we see the the modeldate and the timestamp fields are
stored as character types. Additionally, the timestamp field contains multplie whitespaces. 
Before dumping the data into the MySQL database, we need to clean up the fields.

As the same process needs to be done to each data frame, a function was created to 
address preform the necessary cleansing mentioned above. We do this with the help of
the lubridate package.


```{r}
library(lubridate, quietly = TRUE)

datetime.this <- function(df){
  df$modeldate <- mdy(df$modeldate)
  
  df$timestamp <- str_replace_all(df$timestamp, ' {2}', ' ')
  
  x <- data.frame(str_split(df$timestamp, ':| ', n = 4, simplify = TRUE))
  
  x <- x %>%
    mutate(date = dmy(X4))
  
  x <- x %>%
    mutate(timestamp = as_datetime(paste(date, as.integer(X1), as.integer(X2), as.integer(X3),
                                         sep = ' ')))
  
  df$timestamp <- x$timestamp
  
  return(df)
}


dfEI <- datetime.this(dfEI)
dfPST <- datetime.this(dfPST)
dfPNT <- datetime.this(dfPNT)
dfPEP <- datetime.this(dfPEP)
dfPSA <- datetime.this(dfPSA)

str(dfEI)

```

## Connecting and storing to db

```{r}
#storing the data in google cloud database
library(RMySQL, quietly = TRUE)
con <- dbConnect(MySQL(),
                 user = 'root',
                 host = '35.225.135.85',
                 dbname = 'DATA607')

summary(con)

dbWriteTable(con, 'Presidential_National_Toplines', dfPNT, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_State_Toplines', dfPST, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_EV_Probabilities', dfPEP, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_Scenario_Analysis', dfPSA, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Economic_Index', dfEI, row.names = FALSE, overwrite = TRUE)

dbListTables(con)
```

### Economic Index
The Economic Index table contains economic indicators that serve as inputs to the forecast. 
For more information on these indicators, see this [post](https://fivethirtyeight.com/features/measuring-the-effect-of-the-economy-on-elections/). The economic indexes were collected from the [Federal Reserve Bank Of St. Louis](https://fred.stlouisfed.org/series/DSPIC96) and the stock prices data from [Yahoo Finance](https://finance.yahoo.com/). This sheet contains the following additional columns:


```{r}
res <- dbGetQuery(con, 'select modeldate, category, current_zscore, projected_zscore
                  from Economic_Index;')
res$modeldate <- ymd(res$modeldate)

current <- ggplot(data = res) + 
  geom_smooth(mapping = aes(x = modeldate, y = current_zscore), color = 'brown') +
  geom_smooth(mapping = aes(x = modeldate, y = projected_zscore), color = 'green') +
  facet_wrap(~category) +
  theme(axis.text.x = element_text(angle = 70, hjust = 1))
current + scale_x_date(date_labels = '%m-%Y')
```

## Presidential EV Probabilities table

The Presidential EV Porbabilities table contains the forecasted chances of every possible Electoral College outcome. This table contains only one most recent day's electoral college simulations.

```{r}
str(dfPEP)
```
## Presidential Scenario Analysis

The Presidential Scenario Analysis contains the forecasted chances of various possible election outcome scenarios.


```{r}
str(dfPSA)
```
```{r}
res <- dbGetQuery(con, 'select modeldate, scenario_description, probability from 
                  Presidential_Scenario_Analysis;')

res$modeldate <- ymd(res$modeldate)

probScenario <- ggplot(data = res) +
  geom_line(mapping = aes(modeldate, y = probability, color = scenario_description)) +
  theme(axis.text.x = element_text(angle = 70, hjust = 1))

probScenario + scale_x_date(date_labels = '%m-%Y')
#not very pretty to look at
```



## Presidential National Toplines


contains the final national topline on each day.  
Chances to win electoral votes (Biden in blue, Trump in red)

```{r}
res <- dbGetQuery(con, 'select modeldate, ecwin_inc, ecwin_chal from 
                  Presidential_National_Toplines;')
res$modeldate <- ymd(res$modeldate)


probEWin <- ggplot(data = res) +
  geom_line(mapping = aes(x = modeldate, y = ecwin_inc), color = 'red') +
  geom_line(mapping = aes(x = modeldate, y = ecwin_chal), color = 'blue') +
  theme(axis.text.x =  element_text(angle = 70, hjust = 1))

probEWin + scale_x_date(date_labels = '%m-%Y')


```
## State Toplines


```{r}
res1 <- dbGetQuery(con, 'select modeldate, state, state_turnout, winstate_inc,
                  winstate_chal, tipping from Presidential_State_Toplines;')

res2 <- dbGetQuery(con, 'select state, avg(state_turnout) AVG_Turnout from Presidential_State_Toplines 
                   group by state order by AVG_Turnout desc;')
res2



```





