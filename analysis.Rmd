---
title: "Project 3"
author: "Diego Correa"
date: "9/8/2020"
output:
  pdf_document: default
  html_document: default
---

## Overview



## Loading data

```{r cars, message=FALSE}
library(tidyverse, quietly = TRUE)

#Presidential National Toplines
url1 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_national_toplines_2020.csv'
#Presidential State Toplines
url2 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_state_toplines_2020.csv'
#Presidential EV Probabilities
url3 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_ev_probabilities_2020.csv'
#Presidential Scenario Analysis
url4 <- 'https://projects.fivethirtyeight.com/2020-general-data/presidential_scenario_analysis_2020.csv'
#Economic Index
url5 <- 'https://projects.fivethirtyeight.com/2020-general-data/economic_index.csv'

#Saving data into variables
dfPNT <- read.csv(file = url1)
dfPST <- read.csv(file = url2)
dfPEP <- read.csv(file = url3)
dfPSA <- read.csv(file = url4)
dfEI <- read.csv(file = url5)
```

## Observing & Cleaning 


```{r}
str(dfEI)
# str(dfPNT)
# str(dfPST)
# str(dfPEP)
# str(dfPSA)
```

When we look at the dataframes, we see the the modeldate and the timestamp fields are
stored as character types. Additionally, the timestamp field contains multplie whitespaces. 
Before dumping the data into the MySQL database, we need to clean up the fields.

As the same process needs to be done to each data frame, a function was created to 
address preform the necessary cleansing mentioned above. We do this with the help of
the lubridate package.


```{r}
library(lubridate, quietly = TRUE)

datetime.this <- function(df){
  
  df$modeldate <- mdy(df$modeldate)
  
  df$timestamp <- str_replace_all(df$timestamp, ' {2}', ' ')
  
  x <- data.frame(str_split(df$timestamp, ':| ', n = 4, simplify = TRUE))
  
  x <- x %>%
    mutate(date = dmy(X4))
  
  x <- x %>%
    mutate(timestamp = as_datetime(paste(date, as.integer(X1), as.integer(X2), as.integer(X3),
                                         sep = ' ')))
  
  df$timestamp <- x$timestamp
  
  return(df)
}


dfEI <- datetime.this(dfEI)
dfPST <- datetime.this(dfPST)
dfPNT <- datetime.this(dfPNT)
dfPEP <- datetime.this(dfPEP)
dfPSA <- datetime.this(dfPSA)

str(dfEI)

```

## Connecting and storing to db

```{r message=FALSE}
#storing the data in google cloud database
library(RMySQL, quietly = TRUE)
con <- dbConnect(MySQL(),
                 user = 'root',
                 host = '35.225.135.85',
                 dbname = 'DATA607')

dbWriteTable(con, 'Presidential_National_Toplines', dfPNT, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_State_Toplines', dfPST, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_EV_Probabilities', dfPEP, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Presidential_Scenario_Analysis', dfPSA, row.names = FALSE, overwrite = TRUE)
dbWriteTable(con, 'Economic_Index', dfEI, row.names = FALSE, overwrite = TRUE)
```

### Economic Index
The Economic Index table contains economic indicators that serve as inputs to the forecast. 
For more information on these indicators, see this [post](https://fivethirtyeight.com/features/measuring-the-effect-of-the-economy-on-elections/). The economic indexes were collected from the [Federal Reserve Bank Of St. Louis](https://fred.stlouisfed.org/series/DSPIC96) and the stock prices data from [Yahoo Finance](https://finance.yahoo.com/). This sheet contains the following additional columns:


```{r}
res <- dbGetQuery(con, 'select modeldate, category, current_zscore, projected_zscore
                  from Economic_Index;')
res$modeldate <- ymd(res$modeldate)

current <- ggplot(data = res) + 
  geom_smooth(mapping = aes(x = modeldate, y = current_zscore), color = 'brown') +
  geom_smooth(mapping = aes(x = modeldate, y = projected_zscore), color = 'green') +
  facet_wrap(~category) +
  theme(axis.text.x = element_text(angle = 70, hjust = 1))
current + scale_x_date(date_labels = '%m-%Y')
```

## Presidential EV Probabilities table

The Presidential EV Porbabilities table contains the forecasted chances of every possible Electoral College outcome. This table contains only one most recent day's electoral college simulations.

```{r}
str(dfPEP)
```
## Presidential Scenario Analysis

The Presidential Scenario Analysis contains the forecasted chances of various possible election outcome scenarios.


```{r}
str(dfPSA)
```
```{r}
res <- dbGetQuery(con, 'select modeldate, scenario_description, probability from 
                  Presidential_Scenario_Analysis;')

res$modeldate <- ymd(res$modeldate)

probScenario <- ggplot(data = res) +
  geom_line(mapping = aes(modeldate, y = probability, color = scenario_description)) +
  theme(axis.text.x = element_text(angle = 70, hjust = 1))

<<<<<<< Updated upstream
probScenario + scale_x_date(date_labels = '%m-%Y') + scale_color_discrete(labels = function(x) str_wrap(x, width = 55))
=======
probScenario + scale_x_date(date_labels = '%m-%Y') + scale_color_discrete(labels = function(x) str_wrap(x, width = 65))
>>>>>>> Stashed changes
#not very pretty to look at
```
## State Toplines

Looking at red and blue states

```{r}
res <- dbGetQuery(con, 'select state, avg(winstate_inc) Inc from Presidential_State_Toplines group by state;')

dfStateWin <- res

library(usmap)

plot_usmap(data = dfStateWin, values = 'Inc') + 
<<<<<<< Updated upstream
  scale_fill_continuous(
    low = 'blue', high = 'red', name = 'Projected Vote Outcomes'
  ) + theme(legend.position = 'right')
```

```{r}
res <- dbGetQuery(con, 'select state, avg(win_EC_if_win_state_inc
) Inc, avg(win_EC_if_win_state_chal) Chal from Presidential_State_Toplines group by state;')

dfStateInfluence <- res

plot_usmap(data = dfStateInfluence, values = 'Inc') + 
  scale_fill_continuous(
    low = 'white', high = 'red', name = 'Projected Influence'
  ) + theme(legend.position = 'right')

plot_usmap(data = dfStateInfluence, values = 'Chal') + 
  scale_fill_continuous(
    low = 'white', high = 'blue', name = 'Projected Influence'
  ) + theme(legend.position = 'right')


```
=======
  scale_fill_gradient2(
    low = 'blue', high = 'red', mid = 'white', midpoint = .5, limit = c(0,1),
    name = 'Projected Vote Outcomes'
  ) + theme(legend.position = 'right') +
  labs(title = 'Projected Red and Blue States')
```





#### Voter Turnout by State
>>>>>>> Stashed changes

separating red and blue states based on average probability of winning state

```{r}
<<<<<<< Updated upstream
# Obtaining the average 
res1 <- dbGetQuery(con, 'select state, round(avg(winstate_inc), 4) AVGWinStateInc, 
                   case
                   when avg(winstate_inc) > 0.5 then "Red"
                   when avg (winstate_inc) < 0.5 then "Blue"
                   else "Tie"
                   end "Color"
                   from Presidential_State_Toplines group by state;')

redStates <- res1 %>% 
  filter(Color == 'Red')
redStates <- data.frame(redStates$state)
colnames(redStates) <- 'states'

blueStates <- res1 %>%
  filter(Color == 'Blue')
blueStates <- data.frame(blueStates$state)
colnames(blueStates) <- 'states'

dbWriteTable(con, 'redStates', redStates, overwrite = TRUE)
dbWriteTable(con, 'blueStates', blueStates, overwrite = TRUE)
```

#### Voter Turnout by State




```{r}
res2 <- dbGetQuery(con, 'select state, state_turnout, "red" from Presidential_State_Toplines
                          where state in (select states from redStates);')
redTO <- res2
names(redTO) <- c('state', 'turnout', 'state_color')
  
res3 <- dbGetQuery(con, 'select state, state_turnout, "blue" from Presidential_State_Toplines
                          where state in (select states from blueStates);')
blueTO <- res3
names(blueTO) <- c('state', 'turnout', 'state_color')

df1 <- rbind(redTO, blueTO)
=======
res_state <- dbGetQuery(con, 'select * from Presidential_State_Toplines;')

red_states <- res_state %>%
  group_by(state) %>%
  summarize(avg_winstate_inc = round(mean(winstate_inc, na.rm = TRUE), 3)) %>%
  filter(avg_winstate_inc >= 0.5) %>%
  select(state)

red_state_turnout <- res_state %>%
  semi_join(red_states) %>%
  group_by(state) %>%
  summarize(avg_state_turnout = mean(state_turnout, na.rm = TRUE))

blue_state_turnout <- res_state %>%
  anti_join(red_states) %>%
  group_by(state) %>%
  summarize(avg_state_turnout = mean(state_turnout, na.rm = TRUE))

red_state_turnout['state_color'] <- 'red'
blue_state_turnout['state_color'] <- 'blue'


df1 <- rbind(red_state_turnout, blue_state_turnout)

bp <- ggplot(data = df1, aes(x = state_color, y = avg_state_turnout, fill = state_color)) +
  geom_boxplot() +
  labs(title = 'Projected Turnout of Red & Blue States', subtitle = 'Boxplot')

bp + scale_fill_manual(values = c('blue', 'red'))

den <- ggplot(data = df1, aes(x = avg_state_turnout, fill = state_color)) +
  geom_density(alpha = 0.4)

den + scale_fill_manual(values = c('blue', 'red')) +
  labs(title = 'Projected Turnout of Red & Blue States', subtitle = 'Density')
>>>>>>> Stashed changes

bp <- ggplot(data = df1, aes(x = state_color, y = turnout, fill = state_color)) +
  geom_boxplot()

bp + scale_fill_manual(values = c('blue', 'red'))
```

str(res_state)

states_influence <- res_state %>%
  mutate(total_EC_influence = win_EC_if_win_state_inc + win_state_if_win_EC_chal) %>% 
  group_by(state) %>%
  summarize(avg_EC_Influence = mean(total_EC_influence, na.rm = TRUE)) %>%
  arrange(desc(avg_EC_Influence))


plot_usmap(data = states_influence, values = 'avg_EC_Influence') + 
  scale_fill_gradient2(
    low = 'white', high = 'purple', name = 'Wins EC if Wins State Prob'
  ) + theme(legend.position = 'right') +
  labs(title = 'Wins EC if Wins State Prob')

  
```

## Presidential National Toplines


contains the final national topline on each day.Chances to win electoral votes (Biden in blue, Trump in red)

```{r}
res <- dbGetQuery(con, 'select modeldate, ecwin_inc, ecwin_chal from 
                  Presidential_National_Toplines;')
res$modeldate <- ymd(res$modeldate)


probEWin <- ggplot(data = res) +
  geom_line(mapping = aes(x = modeldate, y = ecwin_inc), color = 'red') +
  geom_line(mapping = aes(x = modeldate, y = ecwin_chal), color = 'blue') +
  theme(axis.text.x =  element_text(angle = 70, hjust = 1))

probEWin + scale_x_date(date_labels = '%m-%Y') +
  labs(title = 'Probability of Incumbent & Challenger Winning Election' , y = 'probability')


```
<<<<<<< Updated upstream
=======

```{r}
res_nat <- dbGetQuery(con, 'select * from Presidential_National_Toplines;')

col <- colnames(res)
chal_col <- str_match(col1, '.*chal.*')
chal_col <- chal_col[!is.na(chal_col)]

dfChal <- res_nat[, chal_col[2:length(chal_col)]]

chal_cormatrix <- round(cor(dfChal), 2)

#new library
library(reshape2, quietly = TRUE)


get_upper_tri <- function(cormatrix){
  cormatrix[lower.tri(cormatrix)] <- NA
  return(cormatrix)
}

chal_reorder_cormatrix <- function(cormatrix){
  dd <- as.dist((1 - cormatrix) / 2)
  hc <- hclust(dd)
  cormatrix <- cormatrix[hc$order, hc$order]
}

chal_cormatrix <- reorder_cormatrix(chal_cormatrix)
chal_upper_triangle <- get_upper_tri(chal_cormatrix)

chal_melted_cormatrix <- melt(chal_upper_triangle, na.rm = TRUE)

ggplot(data = chal_melted_cormatrix, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = 'white') +
  scale_fill_gradient2(low = 'blue', high = 'red', mid = 'white', 
                       midpoint = 0, limit = c(-1,1), space = 'Lab') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 70, hjust = 1)) +
  coord_fixed() +
  labs(title = 'Covariance of Challenger Measures')


inc_col <- str_match(col1, '.*inc.*')
inc_col <- inc_col[!is.na(inc_col)]

dfInc <- res_nat[, inc_col[2:length(inc_col)]]


inc_cormatrix <- round(cor(dfInc), 2)

inc_cormatrix <- reorder_cormatrix(inc_cormatrix)
inc_upper_triangle <- get_upper_tri(inc_cormatrix)

inc_melted_cormatrix <- melt(inc_upper_triangle, na.rm = TRUE)

ggplot(data = inc_melted_cormatrix, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = 'white') +
  scale_fill_gradient2(low = 'blue', high = 'red', mid = 'white', 
                       midpoint = 0, limit = c(-1,1), space = 'Lab') +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 70, hjust = 1)) +
  coord_fixed() + 
  labs(title = 'Covariance of Incumbent Measures')

>>>>>>> Stashed changes






